package my.day15.a.overriding;

public class Child extends Parent{	// 자식클래스

	// 메소드의 오버라이딩 (리모델링) == 메소드의 재정의
	// 메소드의 오버라이딩(overriding) 시 접근제한자는 부모클래스에서 정의해둔 메소드의 접근제한자와 같거나 또는 허용이 더 큰 것을 해야 한다.
	// 또한 메소드의 오버라이딩(overriding) 시 접근제한자 껍데기() { 알맹이 } 중 껍데기(리턴타입 메소드명 파라미터)는 똑같아야 한다.
	// 알맹이(내용물)는 새롭게 정의해서 만들면 된다.
	@Override	// @ 를 애노테이션(어노테이션) 이라고 부른다.
	public String info() {
		return "아이디 : " + super.id + "\n" 
			+  "비밀번호 : " + super.passwd;
	}

	// @Override 를 쓰지 않으면 새로운 Child 클래스에서 새로운 메소드를 만든 것이지만
	// @Override 를 사용하면 부모클래스에서 물려받은 것을 재정의한다고 판단하기 때문에
	// 오타로 inf0() 처럼 쓸 경우 문제가 있음을 인지하지 못한다.
	// @Override 는 알맹이는 바꿀 수 있지만 껍데기(파라미터) 는 바꿀 수 없다.
	// ex) info(int i) 처럼 부모클래스와 다르게 하면 @Override 할 수 없다.
	
	/*
    ---------------------------------------------------------------------------------------------------------------------------
   접근제한자(접근지정자, accessmodifier)   자기자신클래스내부      동일패키지에있는다른클래스      다른패키지에있는하위(자식)클래스       그외의영역  
   --------------------------------------------------------------------------------------------------------------------------- 
   public                                    O                    O                         O                        O  
   protected                                 O                    O                         O                        X
   없음(default)                              O                    O                         X                        X
   private                                   O                    X                         X                        X
*/
	
	// @Override 는 자식클래스가 더 큰 접근제한자일 경우 변경 가능하다. ( 더 작은 것은 안됌.)
	
	
}
